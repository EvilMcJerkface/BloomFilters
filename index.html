<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Bloomfilters : Invertible Bloom filters for efficiently estimating set differences.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Bloomfilters</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/theezak/BloomFilters">View on GitHub</a>

          <h1 id="project_title">Bloomfilters</h1>
          <h2 id="project_tagline">Invertible Bloom filters for efficiently estimating set differences.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/theezak/BloomFilters/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/theezak/BloomFilters/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="invertible-bloom-filters" class="anchor" href="#invertible-bloom-filters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Invertible Bloom Filters</h1>

<p>On using invertible Bloom filters for estimating differences between sets of key/value pairs. Written in C#.</p>

<p>The goal is to efficiently determine the differences between two sets of key/value pairs. </p>

<p>The first approach is based upon invertible Bloom filters, as described in "What’s the Difference? Efﬁcient Set Reconciliation without Prior Context" (David Eppstein, Michael T. Goodrich, Frank Uyeda, George Varghese, 2011, <a href="http://conferences.sigcomm.org/sigcomm/2011/papers/sigcomm/p218.pdf">http://conferences.sigcomm.org/sigcomm/2011/papers/sigcomm/p218.pdf</a>) . A similar data structure, but not extended to detect set differences, is described in "Invertible Bloom Lookup Tables" (Michael T. Goodrich, Michael Mitzenmacher, 2015, <a href="http://arxiv.org/pdf/1101.2245v3.pdf">http://arxiv.org/pdf/1101.2245v3.pdf</a>). </p>

<p>After implementing the data structure as described in the paper, it was noted that the data structure detected changes in the keys, but did not perform equally well at detecting changes in the values. An alternative solution is presented in the form of a reverse invertible Bloom filter.</p>

<p>Included with the Bloom Filter is a strata estimator (as described in the above paper). Based upon the strata estimator, a hybrid strata estimator was implemented utilizing the b-bit minwise hash (described in <a href="http://research.microsoft.com/pubs/120078/wfc0398-liPS.pdf">http://research.microsoft.com/pubs/120078/wfc0398-liPS.pdf</a>). </p>

<p>The estimator is important, because an estimate of the number of differences is needed to pick a proper sized Bloom filter that can be decoded. The size of the invertible Bloom filter needed for detecting the changes between two sets is not dependent upon the set sizes, but upon the size of the difference.  For example, 30 differences between two sets of 500000 elements each can be fully detected by 63 kilobyte invertible Bloom filter. On the other hand, 40000 differences between two sets of 45000 items each can take a Bloom filter of 17 megabytes. </p>

<p>When the estimate for the difference is too large, a Bloom filter will be used that requires more space than needed. When the estimate is too small, a Bloom filter might be used that can't be successfully decoded, additional space and time is required to find a Bloom filter that is large enough to be succesfully decoded.</p>

<h2>
<a id="serialization" class="anchor" href="#serialization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Serialization</h2>

<p>Support has been added for serializing and deserializing Bloom filters and estimators.</p>

<h2>
<a id="overloading-a-bloom-filter" class="anchor" href="#overloading-a-bloom-filter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overloading a Bloom filter</h2>

<p>When utilizing an invertible Bloom filter within the capacity it was sized for, the count will seldom exceed 2 or 3. However, when utilizing estimators, the idea is that the invertible Bloom filter will be utilized at a much higher capacity than it was sized for, thus accepting a higher error rate and much higher count values. To account for both scenario's, the actual count type is configurable. Two types will be supported out of the box: sbyte and int.</p>

<h2>
<a id="computational-overhead" class="anchor" href="#computational-overhead" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Computational overhead</h2>

<p>The cost of computing the value hash can be considerable. If this becomes an issue, a dictionary of keys and pre-computed hash values can be maintained (for example in a NoSQL store). An example of the key-value Bloom filter configuration needed to utilize these precomputed values has been included.</p>

<p>The estimators and Bloom filters themselves can in fact be pre-computed under certain conditions. An estimator can be fully serialized and deserialized for storage. However, since an estimator does not know a Remove operation, an estimator would have to be recomputed after a number of updates or deletes have occured or when the set size becomes significantly larger than the set size that the estimator was sized for. Bloom filters do support deletes (and updates through a combined delete/insert), and thus can be kept in-sync with the data. A number of different sized Bloom filters could be pre-computed and picked from based upon the estimate of the difference. When a comparable sized Bloom filter is not available, you could either give it a best effort (assuming some differences will be recognized, thus reducing the overall number of differences and making progress) or calculate a matching Bloom filter. Note that the size of the pre-calculated estimators and Bloom filters should be agreed upon by the parties involved, since estimators or Bloom filters of different size can't be compared. </p>

<h2>
<a id="wishlist" class="anchor" href="#wishlist" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wishlist</h2>

<p>Although this is initially just a testbed, an obvious wishlist item is a buffer pool to counteract some of the horrible things the Bloom Filter does to memory management.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Bloomfilters maintained by <a href="https://github.com/theezak">theezak</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
